# -*- coding: utf-8 -*-
"""Cópia de catsxdogs_transfer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F0Mi9TkS-3_StfqNTHqfBN-8c8yIYssF


"""

!pip install kaggle
!pip install pillow

#!kaggle competitions download -c dogs-vs-cats
#!kaggle datasets download "center-for-policing-equity/data-science-for-good"
# #!/bin/bash
!curl -L -o /content/dataset1.zip https://www.kaggle.com/api/v1/datasets/download/shaunthesheep/microsoft-catsvsdogs-dataset

from google.colab import files
import kagglehub
import subprocess, os
from pathlib import Path
import os, random, shutil
import pandas as pd
import numpy as np
import os
import tensorflow as tf # Import TensorFlow
import matplotlib.pyplot as plt
from tensorflow.keras.layers import Dense,GlobalAveragePooling2D # Use tf.keras
from tensorflow.keras.applications import MobileNet # Use tf.keras
from tensorflow.keras.preprocessing import image # Use tf.keras
from tensorflow.keras.applications.mobilenet import preprocess_input # Use tf.keras
from tensorflow.keras.preprocessing.image import ImageDataGenerator # Use tf.keras
from tensorflow.keras.models import Model # Use tf.keras
from tensorflow.keras.optimizers import Adam # Use tf.keras
from tensorflow.keras.layers import Dropout # Use tf.keras
from PIL import Image

!rm -rf /content/catsxdogs
!unzip /content/dataset1.zip -d /content/catsxdogs


training_size = 0.7
validation_size = 0.15
test_size = 0.15


# Create a Path object
dog_path = '/content/catsxdogs/PetImages/Dog'
cat_path = '/content/catsxdogs/PetImages/Cat'
PATTERN = "*[0-9]*.jpg"

# Use the glob method on the Path object
image_dog_amount = len(list([f for f in Path(dog_path).glob(f"**/{PATTERN}")]))
image_cat_amount = len(list([f for f in Path(cat_path).glob(f"**/{PATTERN}")]))


print("Dogs: %s"%(image_dog_amount))
print("Cats: %s"%(image_cat_amount))

!mkdir /content/catsxdogs/training_set
!mkdir /content/catsxdogs/validation_set
!mkdir /content/catsxdogs/test_set

!mkdir /content/catsxdogs/training_set/dogs_train
!mkdir /content/catsxdogs/training_set/cats_train

!mkdir /content/catsxdogs/validation_set/dogs_validation
!mkdir /content/catsxdogs/validation_set/cats_validation

!mkdir /content/catsxdogs/test_set/dogs_test
!mkdir /content/catsxdogs/test_set/cats_test

path = dog_path
files = os.listdir(path)

for index, file in enumerate(files):
    os.rename(os.path.join(path, file), os.path.join(path, "dog_"+file))

path = cat_path
files = os.listdir(path)

for index, file in enumerate(files):
    os.rename(os.path.join(path, file), os.path.join(path, "cat_"+file))

def move_files(source, destination, amount):
  # Convert the generator to a list of file paths
  source_glob = Path(source)
  destination_glob = Path(destination)
  all_files = list(source_glob.glob("*.jpg"))

  #Using for loop to randomly choose multiple files
  for i in range(amount):
      #Variable random_file stores the name of the random file chosen
      random_file=random.choice(all_files)
      all_files.remove(random_file)
      source_file= source_glob/random_file # Use source_glob (Path object) for joining paths
      dest_file=destination / random_file.name # Preserve original filename when moving
      #"shutil.move" function moves file from one directory to another
      shutil.move(str(source_file),str(dest_file)) # Convert source_file and dest_file to string
      if i%100 == 0:
        print("%d} %s"%(i+1,random_file))

  print("\n\n"+"$"*33+"[ Files Moved Successfully ]"+"$"*33)


def count_folder_files(source):
  PATTERN = "*[0-9]*.jpg"
  source = Path(source)

  # Use the glob method on the Path object
  count = len(list([f for f in Path(source).glob(f"**/{PATTERN}")]))

  print(f"Files at "+str(source)+f": {count}")


#Prompting user to enter number of files to select randomly along with directory
source_cat=Path('/content/catsxdogs/PetImages/Cat') # Changed to Path object
dest_cat_training=Path('/content/catsxdogs/training_set/cats_train') # Changed to Path object
dest_cat_test=Path('/content/catsxdogs/test_set/cats_test') # Changed to Path object
dest_cat_validation=Path('/content/catsxdogs/validation_set/cats_validation') # Changed to Path object

#dest_cat_training='/content/catsxdogs/training_set'
#dest_cat_test='/content/catsxdogs/test_set'


no_of_cat_files_training=int(image_cat_amount*training_size)
no_of_cat_files_test=int(image_cat_amount*test_size)
no_of_cat_files_validation=int(image_cat_amount*validation_size)


source_dog=Path('/content/catsxdogs/PetImages/Dog') # Changed to Path object
dest_dog_training=Path('/content/catsxdogs/training_set/dogs_train') # Changed to Path object
dest_dog_test=Path('/content/catsxdogs/test_set/dogs_test') # Changed to Path object
dest_dog_validation=Path('/content/catsxdogs/validation_set/dogs_validation') # Changed to Path object

#dest_dog_training='/content/catsxdogs/training_set'
#dest_dog_test='/content/catsxdogs/test_set'


no_of_dog_files_training=int(image_dog_amount*training_size)
no_of_dog_files_test=int(image_dog_amount*test_size)
no_of_dog_files_validation=int(image_dog_amount*validation_size)


print(no_of_dog_files_training, no_of_dog_files_test, no_of_dog_files_validation)
print(no_of_cat_files_training, no_of_cat_files_test, no_of_cat_files_validation)

count_folder_files(source_cat)
count_folder_files(source_dog)

count_folder_files(dest_cat_training)
count_folder_files(dest_cat_validation)
count_folder_files(dest_cat_test)

count_folder_files(dest_dog_training)
count_folder_files(dest_dog_validation)
count_folder_files(dest_dog_test)

move_files(source_cat, dest_cat_training, int(no_of_cat_files_training))
count_folder_files(dest_cat_training)

move_files(source_cat, dest_cat_test, int(no_of_cat_files_test))
count_folder_files(dest_cat_test)

move_files(source_cat, dest_cat_validation, int(no_of_cat_files_validation))
count_folder_files(dest_cat_validation)



move_files(source_dog, dest_dog_training,int(no_of_dog_files_training))
count_folder_files(dest_dog_training)

move_files(source_dog, dest_dog_test,int(no_of_dog_files_test))
count_folder_files(dest_dog_test)

move_files(source_dog, dest_dog_validation,int(no_of_dog_files_validation))
count_folder_files(dest_dog_validation)


"""## CNN - Transfer learning:

Importando o modelo MobileNet que foi previamente treinado no ImageNet e descartando a última camada de neurônios:
"""

model=MobileNet(weights='imagenet',include_top=False)

"""Criando a saída do modelo MobileNet:"""

x=model.output
x=GlobalAveragePooling2D()(x)

"""Adicionando uma camada intermediária e a camada final:"""

x=Dense(50,activation='relu')(x)
preds=Dense(1,activation='sigmoid')(x)
model=Model(inputs=model.input,outputs=preds)

"""Visualizando todas as camadas da nova rede criada usando o modelo MobileNetV2:"""

for i,layer in enumerate(model.layers):
  print(i,layer.name)

"""Definindo qual camada da rede será treinada. Nesse caso somente as duas últimas camadas adicionadas:"""

for layer in model.layers[:88]:
    layer.trainable=False
for layer in model.layers[88:]:
    layer.trainable=True

"""## ImageDataGenerator

Definindo o tamanho de cada batch:
"""

batch_size = 32

# Define a function to validate images
def validate_image(image_path):
  try:
    img = Image.open(image_path)
    img.verify()  # Verify the image integrity
    img.close()
    return True  # Image is valid
  except (IOError, SyntaxError) as e:
    print(f"Invalid image: {image_path}, Error: {e}")
    return False  # Image is invalid

# Define dataset directories
train_dir = '/content/catsxdogs/training_set'
test_dir = 'catsxdogs/test_set'

# Iterate through all images in training and test sets
for dataset_dir in [train_dir, test_dir]:
  for class_name in os.listdir(dataset_dir):
    class_dir = os.path.join(dataset_dir, class_name)
    for image_name in os.listdir(class_dir):
      image_path = os.path.join(class_dir, image_name)
      if not validate_image(image_path):
        # Handle invalid images: remove or skip
        os.remove(image_path)  # Remove the invalid image
        # Alternatively, you could skip the image during training

"""Cada imagem do banco será apresentada a rede de uma forma diferente através do ImageDataGenerator:"""

train_datagen = ImageDataGenerator(rescale = 1./255,
                                   shear_range = 0.4,
                                   zoom_range = 0.4,
                                   height_shift_range=0.3,
                                   width_shift_range=0.3,
                                   rotation_range=50,
                                   horizontal_flip = True)

test_datagen = ImageDataGenerator(rescale = 1./255)

training_set = train_datagen.flow_from_directory('/content/catsxdogs/training_set',
                                                 target_size = (224, 224),
                                                 batch_size = batch_size,
                                                 class_mode = 'binary')

test_set = test_datagen.flow_from_directory('/content/catsxdogs/test_set',
                                            target_size = (224, 224),
                                            batch_size = batch_size,
                                            class_mode = 'binary')

"""## Treinamento

Definindo os parâmetros de compilação da rede:
"""

model.compile(optimizer=Adam(learning_rate = 0.0001),loss='binary_crossentropy',metrics=['accuracy'])

"""Fazendo o treinamento da rede:"""

history = model.fit(training_set,
                    steps_per_epoch= 8000 // batch_size, # Use floor division to get an integer
                    epochs=20,
                    validation_data = test_set,
                    validation_steps = 2000 // batch_size) # Use floor division to get an integer

"""Salvando o modelo para utilização futura:"""

model.save('catsxdogs_mobilenet.h5')
from google.colab import files
files.download('catsxdogs_mobilenet.h5')

"""## Previsão

Mostrando os arquivos da pasta single_prediction com imagens inéditas para a rede classificar:

Escolhendo uma imagem da pasta single_prediction para fazer a previsão:
"""

import random
import os

path = '/content/catsxdogs/validation_set/'

list_files = [val for sublist in [[os.path.join(i[0], j) for j in i[2]] for i in os.walk(path)] for val in sublist]
#print(list_files)
file_name=random.choice(list_files)
print(file_name)
test_image = image.load_img(file_name, target_size = (224, 224))
test_image = image.img_to_array(test_image)
test_image = np.expand_dims(test_image, axis = 0)
test_image = test_image/255

result = model.predict(test_image)

if result[0][0] > 0.5:
    prediction = 'dog'
else:
    prediction = 'cat'

print(prediction)